const std = @import("std");
const mem = std.mem;
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;
const EnumArray = std.EnumArray;
const Writer = std.fs.File.Writer;

const common = @import("common.zig");
const Chunk = @import("chunk.zig").Chunk;
const Object = @import("object.zig").Object;
const Scanner = @import("scanner.zig").Scanner;
const Value = @import("value.zig").Value;
const VM = @import("vm.zig").VM;

const Byte = common.Byte;
const Line = common.Line;
const Closure = Object.Closure;
const Function = Object.Function;
const OpCode = Chunk.OpCode;
const String = Object.String;
const Token = Scanner.Token;

const BYTE_MAX = common.BYTE_MAX;
const SHORT_MAX = common.SHORT_MAX;

pub const ParserError = error{
    CompilerError,
};

/// Parser will read Lox grammar tokens and translate to byte code that the VM can run
pub const Parser = struct {
    pub const Error = ParserError || Allocator.Error || Object.Error || Writer.Error;

    const FunctionType = enum {
        function,
        initializer,
        method,
        script,
    };

    const Local = struct {
        name: []const u8,
        depth: ?Byte,
        is_captured: bool,
    };

    const Upvalue = struct {
        index: Byte,
        is_local: bool,
    };

    /// Compiler will contain compiled Lox byte code instructions
    pub const Compiler = struct {
        enclosing: ?*Compiler,
        function: *Function,
        function_type: FunctionType,
        locals: ArrayList(Local),
        upvalues: ArrayList(Upvalue),
        scope_depth: Byte,

        pub fn create(vm: *VM, typ_: FunctionType, name: *String, enclosing: ?*Compiler) Error!Compiler {
            var compiler = Compiler{
                .enclosing = enclosing,
                .function = try Function.create(vm, name),
                .function_type = typ_,
                .locals = ArrayList(Local).init(vm.allocator),
                .upvalues = ArrayList(Upvalue).init(vm.allocator),
                .scope_depth = 0,
            };
            // GC
            try vm.push(Value{ .object = &compiler.function.obj });
            try compiler.locals.append(
                .{
                    .name = switch (typ_) {
                        .function => "",
                        else => "this",
                    },
                    .depth = 0,
                    .is_captured = false,
                },
            );
            _ = vm.pop();
            return compiler;
        }

        pub fn destroy(self: *Compiler) void {
            // Function will be owned by VM
            self.locals.deinit();
            self.upvalues.deinit();
        }
    };

    const ClassCompiler = struct {
        enclosing: ?*ClassCompiler,
        is_subclass: bool,
    };

    vm: *VM,
    // set during compile
    scanner: Scanner,
    compiler: ?*Compiler,
    current_class: ?*ClassCompiler,
    // will be generated by compile
    current: Token,
    previous: Token,
    in_error: bool,
    in_panic: bool,

    pub fn init(vm: *VM) Parser {
        return .{
            .vm = vm,
            .compiler = null,
            .current_class = null,
            .scanner = undefined,
            .current = undefined,
            .previous = undefined,
            .in_error = false,
            .in_panic = false,
        };
    }

    pub fn deinit(_: Parser) void {} // might not need this

    /// REPLACES: compile (compiler.c)
    pub fn compile(self: *Parser, source: []const u8) Error!*Function {
        self.scanner = Scanner.init(source);

        const name = try String.copy(self.vm, "__script__");
        try self.vm.push(Value{ .object = &name.obj });
        var current = try Compiler.create(self.vm, FunctionType.script, name, null);
        self.compiler = &current;
        defer {
            current.destroy();
            self.compiler = null; // GC
        }
        _ = self.vm.pop();

        try self.advance();
        while (!try self.match(.token_eof)) {
            try self.declaration();
        }

        try self.consume(.token_eof, "Expect end of the expression.");
        return try self.end();
    }

    // REGION: Manipulate Scanner

    fn advance(self: *Parser) Error!void {
        self.previous = self.current;
        while (true) {
            self.current = self.scanner.next();
            if (self.current.type != .token_error) {
                break;
            }
            try self.throwErrorAtCurrent(self.current.slice);
        }
    }

    fn check(self: Parser, expected: Token.Type) bool {
        return self.current.type == expected;
    }

    fn consume(self: *Parser, expected: Token.Type, message: []const u8) Error!void {
        if (self.current.type == expected) {
            try self.advance();
            return;
        }
        try self.throwErrorAtCurrent(message);
    }

    fn match(self: *Parser, expected: Token.Type) Error!bool {
        if (!self.check(expected)) {
            return false;
        }
        try self.advance();
        return true;
    }

    fn synchronize(self: *Parser) Error!void {
        self.in_panic = false;
        while (self.current.type != .token_eof) {
            if (self.previous.type == .token_semicolon) {
                return;
            }
            switch (self.current.type) {
                .token_class, .token_fun, .token_var, .token_for, .token_if, .token_while, .token_print, .token_return => {
                    return;
                },
                else => {},
            }
            try self.advance();
        }
    }

    // REGION: Manipulate Compiler

    /// REPLACES: &current (compiler.c)
    fn getCurrentCompiler(self: *Parser) *Compiler {
        // NOTE: Might want to inline this as well (see below)
        assert(self.compiler != null);
        return self.compiler.?;
    }

    /// REPLACES: currentChunk (compiler.c)
    fn getCurrentChunk(self: *Parser) *Chunk {
        // NOTE: Have to pass back as a pointer in order to modify the Chunk otherwise will run into
        // an error: "error: expected type '*chunk.Chunk', found '*const chunk.Chunk'"
        // Not sure which is a better approach
        // - Saving in the Parser as a *Compiler
        // - Using @constCast
        // - Just using the dot access `self.compiler.?.function.chunk` (probably best way)
        // - Or doing it this way
        return &self.getCurrentCompiler().function.chunk;
    }

    /// REPLACES: makeConstant (compiler.c)
    fn appendConstant(self: *Parser, value: Value) Error!Byte {
        try self.vm.push(value);
        const index = try self.getCurrentChunk().appendConstant(value);
        if (index > BYTE_MAX) {
            try self.throwError("Too many constants in one chunk.");
            return 0;
        }
        _ = self.vm.pop();
        return index;
    }

    fn emitLoop(self: *Parser, start: usize) Error!void {
        try self.emitOp(.op_loop);
        const offset = self.getCurrentChunk().count() - start + 2;
        if (offset >= SHORT_MAX) {
            try self.throwError("Loop body too large.");
        }
        try self.emitByte(@as(Byte, @intCast(offset >> 8 & 0xff)));
        try self.emitByte(@as(Byte, @intCast(offset & 0xff)));
    }

    fn emitOp(self: *Parser, op: OpCode) Error!void {
        try self.getCurrentChunk().writeOp(op, self.previous.line);
    }

    fn emitByte(self: *Parser, byte: Byte) Error!void {
        try self.getCurrentChunk().write(byte, self.previous.line);
    }

    fn emitConstant(self: *Parser, value: Value) Error!void {
        const index = try self.appendConstant(value);
        try self.emitOp(.op_constant);
        try self.emitByte(index);
    }

    fn emitJump(self: *Parser, op: OpCode) Error!usize {
        assert(op == .op_jump or op == .op_jump_if_false);
        try self.emitOp(op);
        try self.emitByte(0xff);
        try self.emitByte(0xff);
        return self.getCurrentChunk().count() - 2;
    }

    fn emitReturn(self: *Parser) Error!void {
        const compiler = self.getCurrentCompiler();
        if (compiler.function_type == .initializer) {
            try self.emitOp(.op_get_local);
            try self.emitByte(0);
        } else {
            try self.emitOp(.op_nil);
        }
        try self.emitOp(.op_return);
    }

    fn patchJump(self: *Parser, offset: usize) Error!void {
        const chunk = self.getCurrentChunk();
        const jump = chunk.count() - offset - 2;
        if (jump >= SHORT_MAX) {
            try self.throwError("Too much code to jump over.");
        }
        chunk.code.items[offset] = @as(Byte, @intCast((jump >> 8) & 0xff));
        chunk.code.items[offset + 1] = @as(Byte, @intCast(jump & 0xff));
    }

    /// REPLACES: endCompiler (compiler.c)
    // TODO: should this be on the compiler?
    fn end(self: *Parser) Error!*Function {
        try self.emitReturn();
        const compiler = self.getCurrentCompiler();
        const func = compiler.function;
        if (common.DEBUG_PRINT_CODE) {
            try func.chunk.disassemble("<end>");
        }
        if (self.in_error) {
            return ParserError.CompilerError;
        }
        if (compiler.enclosing) |enclosing| {
            self.compiler = enclosing;
        }
        return func;
    }

    fn scopeBegin(self: *Parser) void {
        self.getCurrentCompiler().scope_depth += 1;
    }

    fn scopeEnd(self: *Parser) Error!void {
        var compiler = self.getCurrentCompiler();
        compiler.scope_depth -= 1;

        if (compiler.locals.items.len == 0) {
            return;
        }

        var i: usize = 0;
        while (i < compiler.locals.items.len) : (i += 1) {
            const idx = compiler.locals.items.len - 1 - i;
            const local = compiler.locals.items[idx];
            if (local.depth == null or local.depth.? <= compiler.scope_depth) {
                break;
            }
            if (local.is_captured) {
                try self.emitOp(.op_close_upvalue);
            } else {
                try self.emitOp(.op_pop);
            }
            _ = compiler.locals.pop();
        }
    }

    // REGION: Parser Errors

    /// REPLACES: errorAt (compiler.c)
    fn throwErrorAt(self: *Parser, token: Token, message: []const u8) Error!void {
        if (self.in_panic) {
            return;
        }
        self.in_panic = true;
        try self.vm.writer_err.print("[line {d}] Error", .{token.line});
        switch (token.type) {
            .token_eof => try self.vm.writer_err.print(" at end", .{}),
            .token_error => try self.vm.writer_err.print("at '{s}'", .{token.slice}),
            else => {},
        }
        try self.vm.writer_err.print(": {s}\n", .{message});
        self.in_error = true;
    }

    /// REPLACES: error (compiler.c)
    fn throwError(self: *Parser, message: []const u8) Error!void {
        try self.throwErrorAt(self.previous, message);
    }

    /// REPLACES: errorAtCurrent (compiler.c)
    fn throwErrorAtCurrent(self: *Parser, message: []const u8) Error!void {
        try self.throwErrorAt(self.current, message);
    }

    // REGION: Variables

    /// REPLACES: addLocal (compiler.c)
    fn appendLocal(self: *Parser, name: Token) Error!void {
        var compiler = self.getCurrentCompiler();
        if (compiler.locals.items.len > BYTE_MAX) {
            return try self.throwError("Too many local variables in function.");
        }
        try compiler.locals.append(Local{
            .name = name.slice,
            .depth = null,
            .is_captured = false,
        });
    }

    /// REPLACES: addUpvalue (compiler.c)
    fn appendUpvalue(self: *Parser, compiler: *Compiler, index: Byte, is_local: bool) Error!Byte {
        assert(compiler.function.upvalue_count == compiler.upvalues.items.len);
        var i: usize = 0;
        while (i < compiler.function.upvalue_count) : (i += 1) {
            const upvalue = compiler.upvalues.items[i];
            if (upvalue.index == index and upvalue.is_local == is_local) {
                return @as(Byte, @intCast(i));
            }
        }

        if (compiler.upvalues.items.len >= BYTE_MAX) {
            try self.throwError("Too many closure variables in upvalue.");
            return 0; // i guess to let compilation finish in error
        }

        try compiler.upvalues.append(.{
            .is_local = is_local,
            .index = index,
        });
        compiler.function.upvalue_count += 1;
        return @as(Byte, @intCast(compiler.upvalues.items.len - 1));
    }

    fn declareVariable(self: *Parser) Error!void {
        const compiler = self.getCurrentCompiler();
        if (compiler.scope_depth == 0) {
            return;
        }
        const name = self.previous;

        // check for existing local
        var i: usize = 0;
        while (i < compiler.locals.items.len) : (i += 1) {
            const idx = compiler.locals.items.len - 1 - i;
            const local = compiler.locals.items[idx];
            if (local.depth != null and local.depth.? < compiler.scope_depth) {
                break;
            }
            if (mem.eql(u8, name.slice, local.name)) {
                try self.throwError("Already a variable with this name in this scope.");
            }
        }

        try self.appendLocal(name);
    }

    fn defineVariable(self: *Parser, global: Byte) Error!void {
        if (self.getCurrentCompiler().scope_depth > 0) {
            self.markInitialized();
            return;
        }
        try self.emitOp(.op_define_global);
        try self.emitByte(global);
    }

    fn markInitialized(self: *Parser) void {
        var compiler = self.getCurrentCompiler();
        if (compiler.scope_depth == 0) {
            return;
        }
        compiler.locals.items[compiler.locals.items.len - 1].depth = compiler.scope_depth;
    }

    fn identifierConstant(self: *Parser, name: Token) Error!Byte {
        const identifier = try String.copy(self.vm, name.slice[0..]);
        return self.appendConstant(Value{ .object = &identifier.obj });
    }

    fn namedVariable(self: *Parser, name: Token, assignable: bool) Error!void {
        var op_get: OpCode = undefined;
        var op_set: OpCode = undefined;
        var arg: ?Byte = null;
        const compiler = self.getCurrentCompiler();

        if (try self.resolveLocal(compiler, name)) |index| {
            arg = index;
            op_get = .op_get_local;
            op_set = .op_set_local;
        } else if (try self.resolveUpvalue(compiler, name)) |index| {
            arg = index;
            op_get = .op_get_upvalue;
            op_set = .op_set_upvalue;
        } else {
            arg = try self.identifierConstant(name);
            op_get = .op_get_global;
            op_set = .op_set_global;
        }

        if (assignable and try self.match(.token_equal)) {
            try self.expression();
            try self.emitOp(op_set);
            try self.emitByte(arg.?);
        } else {
            try self.emitOp(op_get);
            try self.emitByte(arg.?);
        }
    }

    fn parseVariable(self: *Parser, message_err: []const u8) Error!Byte {
        try self.consume(.token_identifier, message_err);
        try self.declareVariable();
        if (self.getCurrentCompiler().scope_depth > 0) {
            return 0;
        }
        return self.identifierConstant(self.previous);
    }

    fn resolveLocal(self: *Parser, compiler: *Compiler, name: Token) Error!?Byte {
        var i: usize = 0;
        while (i < compiler.locals.items.len) : (i += 1) {
            const idx = compiler.locals.items.len - 1 - i;
            const local = compiler.locals.items[idx];
            if (mem.eql(u8, name.slice, local.name)) {
                if (local.depth == null) {
                    try self.throwError("Can't read local variable in it's own initializer.");
                }
                return @as(Byte, @intCast(idx));
            }
        }
        return null;
    }

    fn resolveUpvalue(self: *Parser, compiler: *Compiler, name: Token) Error!?Byte {
        if (compiler.enclosing == null) {
            return null;
        }

        if (try self.resolveLocal(compiler.enclosing.?, name)) |index| {
            compiler.enclosing.?.locals.items[index].is_captured = true;
            return try self.appendUpvalue(compiler, index, true);
        }
        if (try self.resolveUpvalue(compiler.enclosing.?, name)) |index| {
            return try self.appendUpvalue(compiler, index, false);
        }

        return null;
    }

    // REGION: Lox Grammar

    // > Lox Declarations (produce new bindings)

    fn declaration(self: *Parser) Error!void {
        if (try self.match(.token_class)) {
            try self.classDeclaration();
        } else if (try self.match(.token_fun)) {
            try self.funDeclaration();
        } else if (try self.match(.token_var)) {
            try self.varDeclaration();
        } else {
            try self.statement();
        }

        if (self.in_panic) {
            try self.synchronize();
        }
    }

    fn classDeclaration(self: *Parser) Error!void {
        try self.consume(.token_identifier, "Expect class name.");
        const name_class = self.previous;
        const name_constant = try self.identifierConstant(self.previous);
        try self.declareVariable();
        try self.emitOp(.op_class);
        try self.emitByte(name_constant);
        try self.defineVariable(name_constant);

        var class_compiler = ClassCompiler{ .enclosing = self.current_class, .is_subclass = false };
        self.current_class = &class_compiler;
        // get superclass
        if (try self.match(.token_less)) {
            try self.consume(.token_identifier, "Expect superclass name.");
            try self.variable(false);
            if (mem.eql(u8, name_class.slice, self.previous.slice)) {
                try self.throwError("A class can't inherit from itself.");
            }

            self.scopeBegin();
            try self.appendLocal(.{ .type = .token_identifier, .slice = "super", .line = 0 });
            try self.defineVariable(0);
            try self.namedVariable(name_class, false);
            try self.emitOp(.op_inherit);
            class_compiler.is_subclass = true;
        }

        try self.namedVariable(name_class, false);
        try self.consume(.token_left_brace, "Expect '{' before class body.");
        while (!self.check(.token_right_brace) and !self.check(.token_eof)) {
            try self.method();
        }
        try self.consume(.token_right_brace, "Expect '}' after class body.");

        // exit class declaration
        if (class_compiler.is_subclass) {
            try self.scopeEnd();
        }
        self.current_class = class_compiler.enclosing;
    }

    fn funDeclaration(self: *Parser) Error!void {
        const global = try self.parseVariable("Expect function name.");
        self.markInitialized();
        try self.function(.function);
        try self.defineVariable(global);
    }

    fn varDeclaration(self: *Parser) Error!void {
        const global = try self.parseVariable("Expect variable name.");

        if (try self.match(.token_equal)) {
            try self.expression();
        } else {
            try self.emitOp(.op_nil);
        }
        try self.consume(.token_semicolon, "Expect ';' after variable declaration.");
        try self.defineVariable(global);
    }

    // > Lox Statements (produce side-effects)

    fn statement(self: *Parser) Error!void {
        if (try self.match(.token_print)) {
            try self.printStatement();
        } else if (try self.match(.token_for)) {
            try self.forStatement();
        } else if (try self.match(.token_if)) {
            try self.ifStatement();
        } else if (try self.match(.token_return)) {
            try self.returnStatement();
        } else if (try self.match(.token_while)) {
            try self.whileStatement();
        } else if (try self.match(.token_left_brace)) {
            self.scopeBegin();
            try self.block();
            try self.scopeEnd();
        } else {
            try self.expressionStatement();
        }
    }

    fn expressionStatement(self: *Parser) Error!void {
        try self.expression();
        try self.consume(.token_semicolon, "Expect ';' after value.");
        try self.emitOp(.op_pop);
    }

    fn forStatement(self: *Parser) Error!void {
        self.scopeBegin();
        try self.consume(.token_left_paren, "Expect '(' after 'for'.");

        // initializer
        if (try self.match(.token_semicolon)) {
            // nothing
        } else if (try self.match(.token_var)) {
            try self.varDeclaration();
        } else {
            try self.expression();
        }

        // conditional
        var loop_start = self.getCurrentChunk().count();
        var opt_jump_exit: ?usize = null;
        if (!try self.match(.token_semicolon)) {
            try self.expression();
            try self.consume(.token_semicolon, "Expect ';' after loop condition.");
            opt_jump_exit = try self.emitJump(.op_jump_if_false);
            try self.emitOp(.op_pop);
        }

        // increment
        if (!try self.match(.token_right_paren)) {
            const jump_body = try self.emitJump(.op_jump);
            const increment_start = self.getCurrentChunk().count();
            try self.expression();
            try self.emitOp(.op_pop);
            try self.consume(.token_right_paren, "Expect ')' after for clauses.");

            try self.emitLoop(loop_start);
            loop_start = increment_start;
            try self.patchJump(jump_body);
        }

        try self.statement();
        try self.emitLoop(loop_start);

        if (opt_jump_exit) |jump_exit| {
            try self.patchJump(jump_exit);
            try self.emitOp(.op_pop);
        }

        try self.scopeEnd();
    }

    fn ifStatement(self: *Parser) Error!void {
        try self.consume(.token_left_paren, "Expect '(' after 'if'.");
        try self.expression();
        try self.consume(.token_right_paren, "Expect ')' after condition.");

        const jump_then = try self.emitJump(.op_jump_if_false);
        try self.emitOp(.op_pop);
        try self.statement();

        const jump_else = try self.emitJump(.op_jump);
        try self.patchJump(jump_then);
        try self.emitOp(.op_pop);

        if (try self.match(.token_else)) {
            try self.statement();
        }
        try self.patchJump(jump_else);
    }

    fn printStatement(self: *Parser) Error!void {
        try self.expression();
        try self.consume(.token_semicolon, "Expect ';' after value.");
        try self.emitOp(.op_print);
    }

    fn returnStatement(self: *Parser) Error!void {
        const compiler = self.getCurrentCompiler();
        if (compiler.function_type == .script) {
            try self.throwError("Can't return from top-level code.");
        }

        if (try self.match(.token_semicolon)) {
            try self.emitReturn();
        } else {
            if (compiler.function_type == .initializer) {
                try self.throwError("Can't return a value from an initializer.");
            }
            try self.expression();
            try self.consume(.token_semicolon, "Expect ';' after return value.");
            try self.emitOp(.op_return);
        }
    }

    fn whileStatement(self: *Parser) Error!void {
        const loop_start = self.getCurrentChunk().count();
        try self.consume(.token_left_paren, "Expect '(' after a while.");
        try self.expression();
        try self.consume(.token_right_paren, "Expect ')' after a condition.");

        const jump_exit = try self.emitJump(.op_jump_if_false);
        try self.emitOp(.op_pop);
        try self.statement();
        try self.emitLoop(loop_start);

        try self.patchJump(jump_exit);
        try self.emitOp(.op_pop);
    }

    fn block(self: *Parser) Error!void {
        while (!self.check(.token_right_brace) and !self.check(.token_eof)) {
            try self.declaration();
        }
        try self.consume(.token_right_brace, "Expect '}' after block.");
    }

    // > Lox expressions (produce values)

    fn expression(self: *Parser) Error!void {
        try self.parsePrecedence(.prec_assignment);
    }

    const Precedence = enum {
        prec_none,
        prec_assignment,
        prec_or,
        prec_and,
        prec_equality,
        prec_comparison,
        prec_term,
        prec_factor,
        prec_unary,
        prec_call,
        prec_primary,
    };

    const ParseFn = ?*const fn (*Parser, bool) Error!void;

    const ParseRule = struct {
        prefix: ParseFn = null,
        infix: ParseFn = null,
        precedence: Precedence = .prec_none,
    };

    const parse_rules = EnumArray(Token.Type, ParseRule).init(.{
        // zig fmt: off
        .token_left_paren       = ParseRule{ .prefix = Parser.grouping, .infix = Parser.call,   .precedence = .prec_call },
        .token_right_paren      = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_left_brace       = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_right_brace      = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_comma            = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_dot              = ParseRule{ .prefix = null,            .infix = Parser.dot,          .precedence = .prec_call },
        .token_minus            = ParseRule{ .prefix = Parser.unary,    .infix = Parser.binary, .precedence = .prec_term },
        .token_plus             = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_term },
        .token_semicolon        = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_slash            = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_factor },
        .token_star             = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_factor },
        .token_bang             = ParseRule{ .prefix = Parser.unary,    .infix = null,          .precedence = .prec_none },
        .token_bang_equal       = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_equality },
        .token_equal            = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_equal_equal      = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_equality },
        .token_greater          = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_comparison },
        .token_greater_equal    = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_comparison },
        .token_less             = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_comparison },
        .token_less_equal       = ParseRule{ .prefix = null,            .infix = Parser.binary, .precedence = .prec_comparison },
        .token_identifier       = ParseRule{ .prefix = Parser.variable, .infix = null,          .precedence = .prec_none },
        .token_string           = ParseRule{ .prefix = Parser.string,   .infix = null,          .precedence = .prec_none },
        .token_number           = ParseRule{ .prefix = Parser.number,   .infix = null,          .precedence = .prec_none },
        .token_and              = ParseRule{ .prefix = null,            .infix = Parser.and_,   .precedence = .prec_and },
        .token_class            = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_else             = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_false            = ParseRule{ .prefix = Parser.literal,  .infix = null,          .precedence = .prec_none },
        .token_for              = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_fun              = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_if               = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_nil              = ParseRule{ .prefix = Parser.literal,  .infix = null,          .precedence = .prec_none },
        .token_or               = ParseRule{ .prefix = null,            .infix = Parser.or_,    .precedence = .prec_or },
        .token_print            = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_return           = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_super            = ParseRule{ .prefix = Parser.super,    .infix = null,          .precedence = .prec_none },
        .token_this             = ParseRule{ .prefix = Parser.this,     .infix = null,          .precedence = .prec_none },
        .token_true             = ParseRule{ .prefix = Parser.literal,  .infix = null,          .precedence = .prec_none },
        .token_var              = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_while            = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_error            = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        .token_eof              = ParseRule{ .prefix = null,            .infix = null,          .precedence = .prec_none },
        // zig fmt: on
    });

    pub fn getRule(typ: Token.Type) ParseRule {
        return parse_rules.get(typ);
    }

    fn parsePrecedence(self: *Parser, precedence: Precedence) Error!void {
        try self.advance();
        const opt_prefix: ParseFn = getRule(self.previous.type).prefix orelse {
            try self.throwError("Expect expression.");
            return;
        };

        const assignable = @intFromEnum(precedence) <= @intFromEnum(Precedence.prec_assignment);
        if (opt_prefix) |prefix| {
            try prefix(self, assignable);
        }

        while (@intFromEnum(precedence) <= @intFromEnum(getRule(self.current.type).precedence)) {
            try self.advance();
            const opt_infix: ParseFn = getRule(self.previous.type).infix orelse {
                try self.throwError("Expect infix expression.");
                return;
            };
            if (opt_infix) |infix| {
                try infix(self, assignable);
            }
        }
    }

    fn and_(self: *Parser, _: bool) Error!void {
        const jump_end = try self.emitJump(.op_jump_if_false);
        try self.emitOp(.op_pop);
        try self.parsePrecedence(.prec_and);
        try self.patchJump(jump_end);
    }

    fn binary(self: *Parser, _: bool) Error!void {
        const op = self.previous.type;
        const rule = getRule(op);
        try self.parsePrecedence(@enumFromInt(@intFromEnum(rule.precedence) + 1));
        switch (op) {
            .token_bang_equal => {
                try self.emitOp(.op_equal);
                try self.emitOp(.op_not);
            },
            .token_equal_equal => try self.emitOp(.op_equal),
            .token_greater => try self.emitOp(.op_greater),
            .token_greater_equal => {
                try self.emitOp(.op_less);
                try self.emitOp(.op_not);
            },
            .token_less => try self.emitOp(.op_less),
            .token_less_equal => {
                try self.emitOp(.op_greater);
                try self.emitOp(.op_not);
            },
            .token_plus => try self.emitOp(.op_add),
            .token_minus => try self.emitOp(.op_subtract),
            .token_star => try self.emitOp(.op_multiply),
            .token_slash => try self.emitOp(.op_divide),
            else => unreachable,
        }
    }

    fn call(self: *Parser, _: bool) Error!void {
        const arg_count = try self.argumentList();
        try self.emitOp(.op_call);
        try self.emitByte(arg_count);
    }

    fn dot(self: *Parser, assignable: bool) Error!void {
        try self.consume(.token_identifier, "Expect property name after '.'.");
        const name = try self.identifierConstant(self.previous);

        if (assignable and try self.match(.token_equal)) {
            try self.expression();
            try self.emitOp(.op_set_property);
            try self.emitByte(name);
        } else if (try self.match(.token_left_paren)) {
            const arg_count = try self.argumentList();
            try self.emitOp(.op_invoke);
            try self.emitByte(name);
            try self.emitByte(arg_count);
        } else {
            try self.emitOp(.op_get_property);
            try self.emitByte(name);
        }
    }

    fn grouping(self: *Parser, _: bool) Error!void {
        try self.expression();
        try self.consume(.token_right_paren, "Expect ')' after expression.");
    }

    fn literal(self: *Parser, _: bool) Error!void {
        switch (self.previous.type) {
            .token_false => try self.emitOp(.op_false),
            .token_nil => try self.emitOp(.op_nil),
            .token_true => try self.emitOp(.op_true),
            else => unreachable,
        }
    }

    fn number(self: *Parser, _: bool) Error!void {
        const n: f64 = std.fmt.parseFloat(f64, self.previous.slice) catch 0.0;
        try self.emitConstant(Value{ .number = n });
    }

    fn or_(self: *Parser, _: bool) Error!void {
        const jump_else = try self.emitJump(.op_jump_if_false);
        const jump_end = try self.emitJump(.op_jump);
        try self.patchJump(jump_else);
        try self.emitOp(.op_pop);
        try self.parsePrecedence(.prec_or);
        try self.patchJump(jump_end);
    }

    fn string(self: *Parser, _: bool) Error!void {
        const o_string = try String.copy(self.vm, self.previous.slice[1 .. self.previous.slice.len - 1]);
        try self.emitConstant(Value{ .object = &o_string.obj });
    }

    fn super(self: *Parser, _: bool) Error!void {
        if (self.current_class) |current_class| {
            if (!current_class.is_subclass) {
                return self.throwError("Can't use 'super' in a class with no superclass.");
            }
            try self.consume(.token_dot, "Expect '.' after 'super'.");
            try self.consume(.token_identifier, "Expect superclass method name.");

            const name = try self.identifierConstant(self.previous);
            try self.namedVariable(.{ .type = .token_identifier, .slice = "this", .line = 0 }, false);
            if (try self.match(.token_left_paren)) {
                const arg_count = try self.argumentList();
                try self.namedVariable(.{ .type = .token_identifier, .slice = "super", .line = 0 }, false);
                try self.emitOp(.op_super_invoke);
                try self.emitByte(name);
                try self.emitByte(arg_count);
            } else {
                try self.namedVariable(.{ .type = .token_identifier, .slice = "super", .line = 0 }, false);
                try self.emitOp(.op_get_super);
                try self.emitByte(name);
            }
        } else {
            return self.throwError("Can't use 'super' outside of a class.");
        }
    }

    fn unary(self: *Parser, _: bool) Error!void {
        const op = self.previous.type;
        try self.parsePrecedence(.prec_unary);
        switch (op) {
            .token_minus => try self.emitOp(.op_negate),
            .token_bang => try self.emitOp(.op_not),
            else => unreachable,
        }
    }

    fn variable(self: *Parser, assignable: bool) Error!void {
        return self.namedVariable(self.previous, assignable);
    }

    fn this(self: *Parser, _: bool) Error!void {
        if (self.current_class) |_| {
            try self.variable(false);
            return;
        }
        try self.throwError("Can't use 'this' outside of a class.");
    }

    // REGION: utility functions

    fn argumentList(self: *Parser) Error!Byte {
        var arg_count: Byte = 0;
        if (!self.check(.token_right_paren)) {
            while (true) {
                try self.expression();
                arg_count += 1;
                if (arg_count >= BYTE_MAX) {
                    try self.throwError("Can't have more than 255 arguments");
                }
                if (!try self.match(.token_comma)) {
                    break;
                }
            }
        }
        try self.consume(.token_right_paren, "Expect ')' after arguments.");
        return arg_count;
    }

    fn function(self: *Parser, typ_: FunctionType) Error!void {
        const name = try String.copy(self.vm, self.previous.slice);
        // GC
        try self.vm.push(Value{ .object = &name.obj });
        var current = try Compiler.create(self.vm, typ_, name, self.getCurrentCompiler());
        defer current.destroy();
        _ = self.vm.pop();
        self.compiler = &current;

        self.scopeBegin();
        try self.consume(.token_left_paren, "Expect '(' after function name.");
        if (!self.check(.token_right_paren)) {
            while (true) {
                current.function.arity += 1;
                if (current.function.arity >= BYTE_MAX) {
                    try self.throwErrorAtCurrent("Can't have more than 255 parameters.");
                }
                const constant = try self.parseVariable("Expect parameter name.");
                try self.defineVariable(constant);
                if (!try self.match(.token_comma)) {
                    break;
                }
            }
        }
        try self.consume(.token_right_paren, "Expect ')' after parameters.");
        try self.consume(.token_left_brace, "Expect '{' before function body.");
        try self.block();

        const func = try self.end();
        const value = Value{ .object = &func.obj };
        // GC
        try self.vm.push(value);
        try self.emitOp(.op_closure);
        const constant = try self.appendConstant(value);
        try self.emitByte(constant);
        var i: usize = 0;
        while (i < func.upvalue_count) : (i += 1) {
            try self.emitByte(if (current.upvalues.items[i].is_local) 1 else 0);
            try self.emitByte(current.upvalues.items[i].index);
        }
        _ = self.vm.pop();
    }

    fn method(self: *Parser) Error!void {
        try self.consume(.token_identifier, "Expect method name.");
        const constant = try self.identifierConstant(self.previous);
        var type_: FunctionType = .method;
        if (self.previous.slice.len == 4 and std.mem.eql(u8, "init", self.previous.slice)) {
            type_ = .initializer;
        }
        try self.function(type_);
        try self.emitOp(.op_method);
        try self.emitByte(constant);
    }
};

const testing = std.testing;
const FixtureVM = @import("test.zig").FixtureVM;

test "compile" {
    const fixture = try FixtureVM.init();
    try fixture.setup();
    defer fixture.teardown();

    const f = try fixture.vm.parser.?.compile("1 + -2;");
    try testing.expectEqualStrings("__script__", f.name.chars);
    try testing.expectEqual(9, f.chunk.code.items.len);
}
